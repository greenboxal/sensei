require 'optparse'
require 'ostruct'
require 'fileutils'
require 'pathname'
require 'sensei/package_manager'
require 'rbconfig'

module Sensei
  class << self
    def application
      @application ||= Application.new
    end

    def relative_path_from_build(path)
      path.relative_path_from(application.options.output_directory)
    end

    def change_extension(file, ext)
      filename  = File.basename file, ".*"
      othername = File.join File.dirname(file), "#{filename}#{ext}"
    end

    def is_windows()
      RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
    end
  end

  class Module
    attr_reader :path, :compilers, :parent

    def initialize(parent, path)
      @parent = parent
      @path = path
      @modules = Array.new
      @packages = Array.new
      @compilers = Hash.new
    end

    def add_module(mod)
      @modules << mod
    end

    def add_package(package)
      @packages << package
    end

    def add_compiler(name, compiler)
      @compilers[name] = compiler
    end

    def build
      path = File.join(Sensei.application.options.output_directory, @path)

      FileUtils.mkpath path

      File.open(File.join(path, 'build.ninja'), 'w') do |f|
        f << "# Generated by sensei\n"

        @compilers.each do |k, v|
          CompilerWriter.new f, k, v
          f << "\n"
        end

        @modules.each do |m|
          mpath = File.join(m.path, 'build.ninja')

          f << "subninja #{mpath}\n"
        end

        @packages.each do |p|
          f << "subninja #{File.join(@path, p.name)}.ninja\n"
        end
      end

      @modules.each do |m|
        m.build
      end

      @packages.each do |p|
        File.open(File.join(path, "#{p.name}.ninja"), 'w') do |f|
          f << "# Generated by sensei\n"

          p.write_ninja f
        end
      end
    end
  end

  class Application
    attr_reader :package_manager, :options, :current_module

    def initialize
      @package_manager = PackageManager.new
      @module_stack = Array.new
      @current_module = @root_module
    end

    def enter_module(path)
      path = File.join(@current_module.path, path) unless @current_module == nil

      new_module = Module.new(@current_module, path)
      @module_stack.push @current_module

      if @root_module == nil then
        @root_module = new_module
      else
        @current_module.add_module new_module
      end

      @current_module = new_module
      new_module
    end

    def define_package(package)
      @current_module.add_package package
    end

    def define_compiler(name, compiler)
      @current_module.add_compiler name, compiler
    end

    def exit_module
      @current_module = @module_stack.pop
    end

    def run
      @options = OpenStruct.new
      @options.output_directory = Pathname.new "."
      @options.profile = "Debug"
      @options.generate = false
      @options.verbose = false

      OptionParser.new do |opts|
        opts.banner = "Usage: sensei [options]"

        opts.separator ""
        opts.separator "Options:"

        opts.on("-o", "--out [PATH]", "Output path, defaults current directory") do |path|
          @options.output_directory = Pathname.new(File.realpath(path)).relative_path_from(Pathname.pwd)
        end

        opts.on("-p", "--profile [NAME]", "Profile name, defaults to Debug") do |name|
          @options.profile = name
        end

        opts.on("-g", "--generate [TYPE]", [:msvc], "Generate project files") do |v|
          @options.verbose = v
        end

        opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
          @options.verbose = v
        end

        opts.on_tail("-h", "--help", "Show this message") do
          puts opts
          exit
        end
      end.parse!

      DSL.start
      @root_module.build
    end
  end
end